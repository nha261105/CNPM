pipeline {
    agent any
    
    stages {
        stage('Checkout') {
            steps {
                checkout scm
                echo "Branch: ${env.BRANCH_NAME ?: 'main'} | Build: ${env.BUILD_NUMBER} | ${env.BUILD_DATE}"
            }
        }
        
        stage('Build & Test') {
            parallel {
                stage('Backend') {
                    steps {
                        dir('backend') {
                            echo 'C√†i ƒë·∫∑t dependencies backend...'
                            script {
                                def installStatus = sh(script: 'npm ci --cache $NPM_CONFIG_CACHE --prefer-offline --no-audit --no-fund || npm install', returnStatus: true)
                                if (installStatus != 0) {
                                    error("‚ùå Backend: Kh√¥ng th·ªÉ c√†i ƒë·∫∑t dependencies! Ki·ªÉm tra package.json")
                                }
                            }
                            
                            echo 'üîç Ki·ªÉm tra syntax backend...'
                            script {
                                // FIX: Kh√¥ng d√πng ${PIPESTATUS[0]}, d√πng returnStatus thay th·∫ø
                                def syntaxCheck = sh(script: '''
                                    if [ -f "tsconfig.json" ]; then
                                        npx tsc --noEmit --skipLibCheck 2>&1 | tee /tmp/backend_syntax.log
                                    else
                                        echo "‚ö†Ô∏è Kh√¥ng c√≥ tsconfig.json, skip syntax check"
                                        exit 0
                                    fi
                                ''', returnStatus: true)
                                
                                if (syntaxCheck != 0) {
                                    def errors = sh(script: "cat /tmp/backend_syntax.log || echo 'No log'", returnStdout: true).trim()
                                    error("‚ùå Backend c√≥ l·ªói syntax nghi√™m tr·ªçng:\n${errors}")
                                }
                            }
                            
                            echo '‚ö†Ô∏è Lint warnings (kh√¥ng block pipeline)...'
                            sh 'npm run lint 2>&1 | tee /tmp/backend_lint.log || echo "‚ö†Ô∏è Backend c√≥ lint warnings (non-blocking)"'
                            
                            echo 'üß™ Ch·∫°y tests backend...'
                            sh 'npm run test || true'
                        }
                    }
                }
                stage('Frontend') {
                    steps {
                        dir('frontend') {
                            echo 'C√†i ƒë·∫∑t dependencies frontend...'
                            script {
                                def installStatus = sh(script: 'npm ci --cache $NPM_CONFIG_CACHE --prefer-offline --no-audit --no-fund || npm install', returnStatus: true)
                                if (installStatus != 0) {
                                    error("‚ùå Frontend: Kh√¥ng th·ªÉ c√†i ƒë·∫∑t dependencies! Ki·ªÉm tra package.json")
                                }
                            }
                            
                            echo 'üîç Ki·ªÉm tra syntax & build errors frontend...'
                            script {
                                // Next.js build s·∫Ω b·∫Øt syntax errors v√† missing imports
                                def buildCheck = sh(script: '''
                                    # Dry-run build ƒë·ªÉ catch syntax errors
                                    npm run build 2>&1 | tee /tmp/frontend_build.log || true
                                    
                                    # Ch·ªâ fail n·∫øu c√≥ syntax/parsing errors ho·∫∑c missing modules
                                    if grep -qiE "(SyntaxError|ParseError|Cannot find module|Module not found|expected|unexpected token)" /tmp/frontend_build.log; then
                                        echo "‚ùå Ph√°t hi·ªán l·ªói nghi√™m tr·ªçng!"
                                        exit 1
                                    else
                                        echo "‚úÖ Kh√¥ng c√≥ l·ªói syntax nghi√™m tr·ªçng"
                                        exit 0
                                    fi
                                ''', returnStatus: true)
                                
                                if (buildCheck != 0) {
                                    def criticalErrors = sh(script: """
                                        grep -iE "(SyntaxError|ParseError|Cannot find module|Module not found|expected|unexpected token)" /tmp/frontend_build.log || echo 'See full log above'
                                    """, returnStdout: true).trim()
                                    error("‚ùå Frontend c√≥ l·ªói nghi√™m tr·ªçng (syntax/missing modules):\n${criticalErrors}")
                                }
                            }
                            
                            echo '‚ö†Ô∏è Lint warnings (kh√¥ng block pipeline)...'
                            sh 'npm run lint 2>&1 | tee /tmp/frontend_lint.log || echo "‚ö†Ô∏è Frontend c√≥ lint warnings (non-blocking)"'
                            
                            echo 'üß™ Ch·∫°y tests frontend...'
                            sh 'npm run test || true'
                        }
                    }
                }
            }
        }

        // stage('Code Quality Check') {
        //     parallel {
        //         stage('Lint Backend') {
        //             steps {
        //                 dir('backend') {
        //                     sh 'npm run lint || echo "Backend linting issues found (non-blocking)"'
        //                 }
        //             }
        //         }
        //         stage('Lint Frontend') {
        //             steps {
        //                 dir('frontend') {
        //                     sh 'npm run lint || echo "Frontend linting issues found (non-blocking)"'
        //                 }
        //             }
        //         }
        //     }
        // }

        // stage('Security Scan') {
        //     steps {
        //         dir('backend') { sh 'npm audit --audit-level=high || true' }
        //         dir('frontend') { sh 'npm audit --audit-level=high || true' }
        //     }
        // }

        // stage('Build Docker Images') {
        //     steps {
        //         script {
        //             parallel (
        //                 "Backend Image": {
        //                     sh '''
        //                         echo "üèóÔ∏è Building backend Docker image..."
        //                         docker build \
        //                             --cache-from smartbus-backend:latest \
        //                             --build-arg BUILDKIT_INLINE_CACHE=1 \
        //                             -t smartbus-backend:latest \
        //                             -t smartbus-backend:${BUILD_NUMBER} \
        //                             -f backend/Dockerfile.dev ./backend
        //                     '''
        //                 },
        //                 "Frontend Image": {
        //                     sh '''
        //                         echo "üèóÔ∏è Building frontend Docker image..."
        //                         docker build \
        //                             --cache-from smartbus-frontend:latest \
        //                             --build-arg BUILDKIT_INLINE_CACHE=1 \
        //                             -t smartbus-frontend:latest \
        //                             -t smartbus-frontend:${BUILD_NUMBER} \
        //                             -f frontend/Dockerfile.dev ./frontend
        //                     '''
        //                 }
        //             )
        //             echo "‚úÖ All Docker images built successfully"
        //         }
        //     }
        // }

        // stage('Push Docker Images') {
        //     steps {
        //         script {
        //             withCredentials([usernamePassword(credentialsId: 'dockerhub', usernameVariable: 'DOCKER_USER', passwordVariable: 'DOCKER_PASS')]) {
        //                 sh 'echo $DOCKER_PASS | docker login -u $DOCKER_USER --password-stdin'
        //                 sh 'docker tag smartbus-backend:latest $DOCKER_USER/smartbus-backend:latest'
        //                 sh 'docker tag smartbus-frontend:latest $DOCKER_USER/smartbus-frontend:latest'
        //                 sh 'docker push $DOCKER_USER/smartbus-backend:latest'
        //                 sh 'docker push $DOCKER_USER/smartbus-frontend:latest'
        //             }
        //         }
        //     }
        // }

        // stage('Deploy to Development') {
        //     steps { 
        //         timeout(time: 5, unit: 'MINUTES') {
        //             script {
        //                 try {
        //                     sh '''
        //                         echo "üöÄ Starting development deployment..."
        //                         bash scripts/deploy-dev.sh
        //                     '''
        //                     echo "‚úÖ Development deployment completed successfully!"
        //                 } catch (Exception e) {
        //                     echo "‚ùå Development deployment failed: ${e.getMessage()}"
        //                     sh 'docker compose -f docker-compose.dev.yml logs --tail=50 || true'
        //                     throw e
        //                 }
        //             }
        //         }
        //     }
        // }

        // stage('Deploy to Staging') {
        //     steps { 
        //         sh 'bash scripts/deploy-staging.sh' 
        //     }
        // }

        stage('Deploy Services') {
            parallel {
                stage('Deploy Frontend (Vercel)') {
                    steps {
                        timeout(time: 30, unit: 'SECONDS') {
                            echo 'Triggering Vercel deployment...'
                            sh '''
                                set -euo pipefail
                                echo "Calling Vercel deploy hook..."
                                HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 20 -X POST \
                                    "https://api.vercel.com/v1/integrations/deploy/prj_clKk0bSXKxWNDvdaiCTiTstGTVPS/YCJaNRda40")
                                echo "Vercel HTTP status: $HTTP_CODE"
                                if [ "$HTTP_CODE" -ge 200 ] && [ "$HTTP_CODE" -lt 300 ]; then
                                    echo "‚úÖ Vercel deployment triggered successfully"
                                else
                                    echo "‚ö†Ô∏è Vercel hook returned status $HTTP_CODE (non-blocking)"
                                fi
                            '''
                        }
                    }
                }
                
                stage('Deploy Backend (Render)') {
                    steps {
                        timeout(time: 30, unit: 'SECONDS') {
                            echo 'Triggering Render deployment...'
                            sh '''
                                set -euo pipefail
                                echo "Calling Render deploy hook..."
                                HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 20 -X POST \
                                    "https://api.render.com/deploy/srv-d4hjsb0dl3ps739r80jg?key=n5Ktij-19n8")
                                echo "Render HTTP status: $HTTP_CODE"
                                if [ "$HTTP_CODE" -ge 200 ] && [ "$HTTP_CODE" -lt 300 ]; then
                                    echo "‚úÖ Render deployment triggered successfully"
                                else
                                    echo "‚ö†Ô∏è Render hook returned status $HTTP_CODE (non-blocking)"
                                fi
                            '''
                        }
                    }
                }
            }
        }

        // stage('Smoke Tests') {
        //     when { branch 'main' }
        //     steps {
        //         echo 'Running smoke tests...'
        //         sh '''
        //             sleep 10
        //             # Customize these URLs for your real endpoints:
        //             # curl -f http://localhost:3000/ || echo "FE not ready"
        //             # curl -f https://your-backend.example.com/health || echo "BE not ready"
        //             echo "Smoke tests skipped by default (customize Jenkinsfile)."
        //         '''
        //     }
        // }
    }

    post {
        success { 
            echo "‚úÖ Pipeline completed successfully!" 
        }
        failure { 
            echo "‚ùå Pipeline failed - check console output for details" 
        }
        always {
            echo "Cleaning workspace..."
            // cleanWs()  // ƒê√£ comment ƒë·ªÉ tr√°nh l·ªói plugin kh√¥ng t·ªìn t·∫°i
        }
    }
}
